# Java虚拟机

## 01、JVM内存结构
### 结构图
![JVM内存结构](https://user-images.githubusercontent.com/49053144/202995928-ccf8246c-23d0-4641-8c77-f6f643740a0a.png)
### 描述
  1. 创建 JVM，调用类加载子系统加载 class，将类的信息存入**方法区**
  2. 创建 main 线程，使用的内存区域是 **JVM 虚拟机栈**，开始执行 main 方法代码
  3. 如果遇到了未见过的类，会继续触发类加载过程，同样会存入**方法区**
  4. 需要创建对象，会使用**堆**内存来存储对象
  5. 不再使用的对象，会由**垃圾回收器**在内存不足时回收其内存
  6. 调用方法时，方法内的局部变量、方法参数所使用的是  **JVM 虚拟机栈**中的栈帧内存
  7. 调用方法时，先要到**方法区**获得到该方法的字节码指令，由**解释器**将字节码指令解释为机器码执行
  8. 调用方法时，会将要执行的指令行号读到**程序计数器**，这样当发生了线程切换，恢复时就可以从中断的位置继续
  9. 对于非 java 实现的方法调用，使用内存称为**本地方法栈**（见说明）
  10. 对于热点方法调用，或者频繁的循环代码，由 **JIT 即时编译器**将这些代码编译成机器码缓存，提高执行性能
  
### 总结：
   1. JVM Stacks虚拟机栈：局部变量、方法参数等；
   2. Method Area（方法区）：类信息和方法信息；
   3. Heap（堆）：java对象信息；
   4. PC Register（程序计数器）主要是记录线程执行代码的行数
   5. Interpreter（解释器）：将字节码解释成机器码；
   6. JIT Compiler（即时编译器）：发现热点代码缓存成机器码，之后 如果再遇到直接使用；
   7. **线程私有**：程序计数器和虚拟机栈；**线程共享**：堆和方法区；
   9. 对于Oracl的Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈的。
  
### 问题：
#### 1、哪些部分会出现内存溢出？
    除了程序计数器，都会出现内存溢出；
  * 出现OutOfMemoryError的情况
    * 堆内存耗尽：对象越来越多，又一直在使用不能被垃圾回收；
    * 方法区内存耗尽：加载的类越来越多，很多框架都会在运行期间动态产生新的类；一般不太有这种情况，因为物理内存有多大，就能用多大的方法区内存；
    * 虚拟机栈累积：每个线程最多占用 1M 内存，线程个数越来越多，而又长时间运行不销毁。
  * 出现StackOverflowError的区域
    * 虚拟机栈内部：方法调用次数过多，如递归没加终止。
#### 2、方法区与永久代、元空间之间的关系
  * 方法区是JVM 规范中 **定义**  的一块内存区域，用来存储类元数据、方法字节码，即时编译器需要的信息等；
  * 永久代是Oracl的Hotspot虚拟机对JVM规范的实现（1.8之前）；
  * 元空间是Oracl的Hotspot虚拟机对JVM规范的实现（1.8之后），使用本地内存作为这些信息的存储空间；
![堆与元空间 01](https://user-images.githubusercontent.com/49053144/203011184-811df2e0-f8c5-4094-a20f-51764c1d23ae.png)
   * 当第一次用到某个类时，由类加载器将 class 文件的类元信息读入到元空间中，并存储；
   * 图中 X，Y 的类元信息是存储在元空间中的，无法直接访问的；需要通过堆中的X.class、Y.class 间接访问类元信息，它们两个属于Java对象，代码中是可以使用的。
![堆与元空间 02](https://user-images.githubusercontent.com/49053144/203013169-abdc1509-e1a8-48dc-83d7-031dd082e690.png)
   * 在堆内存中，一个**类加载器对象**加载的**所有对象**，如果这些对象对应的**所有实例对象**都没有引用时，GC时就会对它们占用的堆内存进行释放；
   * 元空间中的内存释放**以类加载器为单位**，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放。
   * 在整个类加载没了，才会把元空间中的对应的类清除，自定义的类加载器才可被释放。
  
   
