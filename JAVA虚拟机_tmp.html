<!DOCTYPE html>
<html>
<head>
<title>JAVA虚拟机.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="java%E8%99%9A%E6%8B%9F%E6%9C%BA">Java虚拟机</h1>
<h2 id="01jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">01、JVM内存结构</h2>
<h3 id="%E7%BB%93%E6%9E%84%E5%9B%BE">结构图</h3>
<p><img src="https://user-images.githubusercontent.com/49053144/202995928-ccf8246c-23d0-4641-8c77-f6f643740a0a.png" alt="JVM内存结构"></p>
<h3 id="%E6%8F%8F%E8%BF%B0">描述</h3>
<ol>
<li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li>
<li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li>
<li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li>
<li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li>
<li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li>
<li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li>
<li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li>
<li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li>
<li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li>
<li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li>
</ol>
<h3 id="%E6%80%BB%E7%BB%93">总结：</h3>
<ol>
<li>JVM Stacks虚拟机栈：局部变量、方法参数等；</li>
<li>Method Area（方法区）：类信息和方法信息；</li>
<li>Heap（堆）：java对象信息；</li>
<li>PC Register（程序计数器）主要是记录线程执行代码的行数</li>
<li>Interpreter（解释器）：将字节码解释成机器码；</li>
<li>JIT Compiler（即时编译器）：发现热点代码缓存成机器码，之后 如果再遇到直接使用；</li>
<li><strong>线程私有</strong>：程序计数器和虚拟机栈；<strong>线程共享</strong>：堆和方法区；</li>
<li>对于Oracl的Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈的。</li>
</ol>
<h3 id="%E9%97%AE%E9%A2%98">问题：</h3>
<h4 id="1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">1、哪些部分会出现内存溢出？</h4>
<pre><code>除了程序计数器，都会出现内存溢出；
</code></pre>
<ul>
<li>出现OutOfMemoryError的情况
<ul>
<li>堆内存耗尽：对象越来越多，又一直在使用不能被垃圾回收；</li>
<li>方法区内存耗尽：加载的类越来越多，很多框架都会在运行期间动态产生新的类；一般不太有这种情况，因为物理内存有多大，就能用多大的方法区内存；</li>
<li>虚拟机栈累积：每个线程最多占用 1M 内存，线程个数越来越多，而又长时间运行不销毁。</li>
</ul>
</li>
<li>出现StackOverflowError的区域
<ul>
<li>虚拟机栈内部：方法调用次数过多，如递归没加终止。</li>
</ul>
</li>
</ul>
<h4 id="2%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%8E%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%85%83%E7%A9%BA%E9%97%B4%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">2、方法区与永久代、元空间之间的关系</h4>
<ul>
<li>方法区是JVM 规范中 <strong>定义</strong>  的一块内存区域，用来存储类元数据、方法字节码，即时编译器需要的信息等；</li>
<li>永久代是Oracl的Hotspot虚拟机对JVM规范的实现（1.8之前）；</li>
<li>元空间是Oracl的Hotspot虚拟机对JVM规范的实现（1.8之后），使用本地内存作为这些信息的存储空间；
<img src="https://user-images.githubusercontent.com/49053144/203011184-811df2e0-f8c5-4094-a20f-51764c1d23ae.png" alt="堆与元空间 01"></li>
<li>当第一次用到某个类时，由类加载器将 class 文件的类元信息读入到元空间中，并存储；</li>
<li>图中 X，Y 的类元信息是存储在元空间中的，无法直接访问的；需要通过堆中的X.class、Y.class 间接访问类元信息，它们两个属于Java对象，代码中是可以使用的。
<img src="https://user-images.githubusercontent.com/49053144/203013169-abdc1509-e1a8-48dc-83d7-031dd082e690.png" alt="堆与元空间 02"></li>
<li>在堆内存中，一个<strong>类加载器对象</strong>加载的<strong>所有对象</strong>，如果这些对象对应的<strong>所有实例对象</strong>都没有引用时，GC时就会对它们占用的堆内存进行释放；</li>
<li>元空间中的内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放。</li>
<li>在整个类加载没了，才会把元空间中的对应的类清除，自定义的类加载器才可被释放。</li>
</ul>
<h2 id="02jvm%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0">02、JVM内存参数</h2>
<pre><code>先看一个问题：
对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5210m -XX:SurvivorRatio=3 其最小内存值和Survivor区总大小分别是？
答:通过 （图按大小设置） 参数了解，可以知道堆内存的最大值和最小值都为10G，新生代的内存为5G，则老年代内存也会分到5G；
   再看 (图按比例设置)参数比 和 -XX:SurvivorRatio=3 了解，eden 与 from（from和to大小一样）比为3:1，则 5120m/5=1024m，
   Survivor总大小 = 1024m*2 = 2048m = 2G。
</code></pre>
<h3 id="%E5%8F%82%E6%95%B0%E4%BA%86%E8%A7%A3">参数了解</h3>
<ul>
<li>-Xmx 最小堆内存（包括新生代和老生代）</li>
<li>-Xms 最大堆内存（同上）</li>
<li>一般建议 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li>
<li>-Xmn 新生代大小，相当于同时设置 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等
<ul>
<li>-XX:NewSize 新生化最小值</li>
<li>-XX:MaxNewSize 新生代最大值</li>
<li>一般不建议设置，由 JVM 自己控制</li>
</ul>
</li>
<li>如果 最大值 与 最小值 设置不一样，那它们之间有区间则称<strong>保留</strong>，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。</li>
<li>如下图：<br>
<img src="https://user-images.githubusercontent.com/49053144/203018981-6fbf8930-031e-47e2-8122-866a969757b3.png" alt="按大小设置"></li>
<li>上面是<strong>按大小设置</strong>堆内存的参数，下图<strong>按比例设置</strong>
<img src="https://user-images.githubusercontent.com/49053144/203019603-f21f06b0-8d88-4d84-8527-ab1420f9fd84.png" alt="按比例设置"></li>
<li>如上图：<strong>-XX:NewRatio=2:1</strong> 表示老年代占两份，新生代占一份；<strong>-XX:SurvivorRatio=4:1</strong> 表示新生代分成6份，伊甸园占4份，form 和 to 各点一份。</li>
<li><strong>元空间内存设置</strong>如下图：</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/49053144/203020673-33f0e289-3d4b-4905-a720-869c3daf82dd.png" alt="元空间内存设置"></p>
<ul>
<li>class space： 存储类的基本信息</li>
<li>-XX:CompressedClassSpaceSize: 控制最大值</li>
<li>non-class space: 存储除类的基本信息以外的其它信息（如 方法字节码、注解等）</li>
<li>-XX:MaxMetaspaceSize：控制 class space 和 non-class space 总大小
<strong>注意</strong></li>
<li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，可认为指针压缩默认开启</li>
</ul>
<h3 id="%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE">其他参数设置</h3>
<ul>
<li><strong>代码缓存内存设置</strong></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/49053144/203265175-9b83938a-83cc-427e-8822-a9e81201d8a5.png" alt="代码缓存内存设置"></p>
<ul>
<li>
<p>使用场景在JIT 计时编译器，缓存编译后的机器码的</p>
</li>
<li>
<p>当 -XX:ReservedCodeCacheSize &lt; 240m 时，所有优化机器代码不加区分一起</p>
</li>
<li>
<p>则会分成 三个区域</p>
<ul>
<li>non-nmethods - JVM 自己用的代码</li>
<li>profiled nmethods - 部分优化的机器码</li>
<li>non-profiled nmethods - 完全优化的机器码</li>
</ul>
</li>
<li>
<p><strong>线程内存设置</strong></p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/49053144/203261601-eb4416a6-a2a7-45ff-92c3-9becdd760d4d.png" alt="线程内存设置"></p>
<blockquote>
<p><em><strong>官方参考文档</strong></em></p>
<ul>
<li>https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</li>
</ul>
</blockquote>
<h2 id="3-jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">3. JVM 垃圾回收</h2>
<p><strong>要求</strong></p>
<ul>
<li>掌握垃圾回收算法</li>
<li>掌握分代回收思想</li>
<li>理解三色标记及漏标处理</li>
<li>了解常见垃圾回收器</li>
</ul>
<p><strong>三种垃圾回收算法</strong></p>
<p>标记清除法</p>
<p><img src="file:///d:/img/image-20210831211008162.png" alt="image-20210831211008162"></p>
<p>解释：</p>
<ol>
<li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li>
<li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li>
<li>清除阶段：释放未加标记的对象占用的内存</li>
</ol>
<p>要点：</p>
<ul>
<li>标记速度与存活对象线性关系</li>
<li>清除速度与内存大小线性关系</li>
<li>缺点是会产生内存碎片</li>
</ul>
<p>标记整理法</p>
<p><img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831211641241.png" alt="image-20210831211641241"></p>
<p>解释：</p>
<ol>
<li>前面的标记阶段、清理阶段与标记清除法类似</li>
<li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li>
</ol>
<p>特点：</p>
<ul>
<li>
<p>标记速度与存活对象线性关系</p>
</li>
<li>
<p>清除与整理速度与内存大小成线性关系</p>
</li>
<li>
<p>缺点是性能上较慢</p>
</li>
</ul>
<p>标记复制法</p>
<p><img src="file:///d:/img/image-20210831211641241.png" alt="image-20210831212125813"></p>
<p>解释：</p>
<ol>
<li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li>
<li>标记阶段与前面的算法类似</li>
<li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li>
<li>复制完成后，交换 from 和 to 的位置即可</li>
</ol>
<p>特点：</p>
<ul>
<li>标记与复制速度与存活对象成线性关系</li>
<li>缺点是会占用成倍的空间</li>
</ul>
<p><strong>GC 与分代回收算法</strong></p>
<p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p>
<p>GC 要点：</p>
<ul>
<li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li>
<li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>
<li>GC 具体的实现称为<strong>垃圾回收器</strong></li>
<li>GC 大都采用了<strong>分代回收思想</strong>
<ul>
<li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li>
<li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li>
</ul>
</li>
<li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li>
</ul>
<p><strong>分代回收</strong></p>
<ol>
<li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li>
</ol>
<p><img src="file:///d:/img/image-20210831213622704.png" alt="image-20210831213622704"></p>
<ol start="2">
<li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="file:///d:/img/image-20210831213640110.png" alt="image-20210831213640110"></p>
<ol start="3">
<li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="file:///d:/img/image-20210831213657861.png" alt="image-20210831213657861"></p>
<ol start="4">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="file:///d:/img/image-20210831213708776.png" alt="image-20210831213708776"></p>
<ol start="5">
<li>经过一段时间后伊甸园的内存又出现不足</li>
</ol>
<p><img src="file:///d:/img/image-20210831213724858.png" alt="image-20210831213724858"></p>
<ol start="6">
<li>标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="file:///d:/img/image-20210831213737669.png" alt="image-20210831213737669"></p>
<ol start="7">
<li>将存活对象采用复制算法复制到 to 中</li>
</ol>
<p><img src="file:///d:/img/image-20210831213804315.png" alt="image-20210831213804315"></p>
<ol start="8">
<li>复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="file:///d:/img/image-20210831213815371.png" alt="image-20210831213815371"></p>
<ol start="9">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="file:///d:/img/image-20210831213826017.png" alt="image-20210831213826017"></p>
<ol start="10">
<li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li>
</ol>
<p><strong>GC 规模</strong></p>
<ul>
<li>
<p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
</li>
<li>
<p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p>
</li>
<li>
<p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</li>
</ul>
<p><strong>三色标记</strong></p>
<p>即用三种颜色记录对象的标记状态</p>
<ul>
<li>黑色 – 已标记</li>
<li>灰色 – 标记中</li>
<li>白色 – 还未标记</li>
</ul>
<ol>
<li>起始的三个对象还未处理完成，用灰色表示</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;">
<ol start="2">
<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;">
<ol start="3">
<li>依次类推</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;">
<ol start="4">
<li>沿着引用链都标记了一遍</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;">
<ol start="5">
<li>最后为标记的白色对象，即为垃圾</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;">
<p><strong>并发漏标问题</strong></p>
<p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p>
<ol>
<li>如图所示标记工作尚未完成</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;">
<ol start="2">
<li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;">
<ol start="3">
<li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;">
<ol start="4">
<li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;">
<p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p>
<ol>
<li>Incremental Update 增量更新法，CMS 垃圾回收器采用
<ul>
<li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li>
</ul>
</li>
<li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用
<ul>
<li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li>
<li>新加对象会被记录</li>
<li>被删除引用关系的对象也被记录</li>
</ul>
</li>
</ol>
<p><strong>垃圾回收器 - Parallel GC</strong></p>
<ul>
<li>
<p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p>
</li>
<li>
<p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p>
</li>
<li>
<p><strong>注重吞吐量</strong></p>
</li>
</ul>
<p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p>
<ul>
<li>
<p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p>
<ul>
<li>并发标记时不需暂停用户线程</li>
<li>重新标记时仍需暂停用户线程</li>
</ul>
</li>
<li>
<p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p>
</li>
<li>
<p><strong>注重响应时间</strong></p>
</li>
</ul>
<p><strong>垃圾回收器 - G1 GC</strong></p>
<ul>
<li><strong>响应时间与吞吐量兼顾</strong></li>
<li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li>
<li>分成三个阶段：新生代回收、并发标记、混合收集</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>
</ul>
<p><strong>G1 回收阶段 - 新生代回收</strong></p>
<ol>
<li>初始时，所有区域都处于空闲状态</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;">
<ol start="2">
<li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;">
<ol start="3">
<li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;">
<ol start="4">
<li>复制完成，将之前的伊甸园内存释放</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;">
<ol start="5">
<li>随着时间流逝，伊甸园的内存又有不足</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;">
<ol start="6">
<li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;">
<ol start="7">
<li>释放伊甸园以及之前幸存区的内存</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;">
<p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p>
<ol>
<li>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;">
<ol start="2">
<li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;">
<ol start="3">
<li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;">
<ol start="4">
<li>下图显示了老年代和幸存区晋升的存活对象的复制</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;">
<ol start="5">
<li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;">
<h2 id="4-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">4. 内存溢出</h2>
<p><strong>要求</strong></p>
<ul>
<li>能够说出几种典型的导致内存溢出的情况</li>
</ul>
<p><strong>典型情况</strong></p>
<ul>
<li>误用线程池导致的内存溢出
<ul>
<li>参考 JavaLearn项目中learJVM.TestOomThreadPool</li>
</ul>
</li>
<li>查询数据量太大导致的内存溢出
<ul>
<li>参考 JavaLearn项目中learJVM.TestOomTooManyObject</li>
</ul>
</li>
<li>动态生成类导致的内存溢出
<ul>
<li>参考 JavaLearn项目中learJVM.TestOomTooManyClass</li>
</ul>
</li>
</ul>
<h2 id="5-%E7%B1%BB%E5%8A%A0%E8%BD%BD">5. 类加载</h2>
<p><strong>要求</strong></p>
<ul>
<li>掌握类加载阶段</li>
<li>掌握类加载器</li>
<li>理解双亲委派机制</li>
</ul>
<p><strong>类加载过程的三个阶段</strong></p>
<ol>
<li>
<p>加载</p>
<ol>
<li>
<p>将类的字节码载入方法区，并创建类.class 对象</p>
</li>
<li>
<p>如果此类的父类没有加载，先加载父类</p>
</li>
<li>
<p>加载是懒惰执行</p>
</li>
</ol>
</li>
<li>
<p>链接</p>
<ol>
<li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li>
<li>准备 – 为 static 变量分配空间，设置默认值</li>
<li>解析 – 将常量池的符号引用解析为直接引用</li>
</ol>
</li>
<li>
<p>初始化</p>
<ol>
<li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li>
<li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li>
<li>初始化是懒惰执行</li>
</ol>
</li>
</ol>
<blockquote>
<p><em><strong>验证手段</strong></em></p>
<ul>
<li>使用 jps 查看进程号</li>
<li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面
<ul>
<li>Class Browser 可以查看当前 jvm 中加载了哪些类</li>
<li>控制台的 universe 命令查看堆内存范围</li>
<li>控制台的 g1regiondetails 命令查看 region 详情</li>
<li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li>
<li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li>
</ul>
</li>
<li>使用 javap 命令可以查看 class 字节码</li>
</ul>
</blockquote>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>JavaLearn项目中learJVM.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li>
<li>JavaLearn项目中learJVM.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li>
</ul>
</blockquote>
<p><strong>jdk 8 的类加载器</strong></p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>加载哪的类</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Bootstrap ClassLoader</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为 Bootstrap，显示为  null</td>
</tr>
<tr>
<td>Application ClassLoader</td>
<td>classpath</td>
<td>上级为 Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为 Application</td>
</tr>
</tbody>
</table>
<p><strong>双亲委派机制</strong></p>
<p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p>
<ul>
<li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li>
<li>找不到这个类，则下级类加载器才有资格执行加载</li>
</ul>
<p>双亲委派的目的有两点</p>
<ol>
<li>
<p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p>
</li>
<li>
<p>让类的加载有优先次序，保证核心类优先加载</p>
</li>
</ol>
<p><strong>对双亲委派的误解</strong></p>
<p>下面面试题的回答是错误的</p>
<p><img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901110910016.png" alt="image-20210901110910016"></p>
<p>错在哪了？</p>
<ul>
<li>
<p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p>
</li>
<li>
<p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p>
</li>
<li>
<p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p>
</li>
<li>
<p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p>
</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>JavaLearn项目中learJVM.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li>
</ul>
</blockquote>
<h2 id="6-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8">6. 四种引用</h2>
<p><strong>要求</strong></p>
<ul>
<li>掌握四种引用</li>
</ul>
<p><strong>强引用</strong></p>
<ol>
<li>
<p>普通变量赋值即为强引用，如 A a = new A();</p>
</li>
<li>
<p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p>
</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901111903574.png" alt="image-20210901111903574" style="zoom:80%;">
<p><strong>软引用（SoftReference）</strong></p>
<ol>
<li>
<p>例如：SoftReference a = new SoftReference(new A());</p>
</li>
<li>
<p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p>
</li>
<li>
<p>软引用自身需要配合引用队列来释放</p>
</li>
<li>
<p>典型例子是反射数据</p>
</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901111957328.png" alt="image-20210901111957328" style="zoom:80%;">
<p><strong>弱引用（WeakReference）</strong></p>
<ol>
<li>
<p>例如：WeakReference a = new WeakReference(new A());</p>
</li>
<li>
<p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p>
</li>
<li>
<p>弱引用自身需要配合引用队列来释放</p>
</li>
<li>
<p>典型例子是 ThreadLocalMap 中的 Entry 对象</p>
</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901112107707.png" alt="image-20210901112107707" style="zoom:80%;">
<p><strong>虚引用（PhantomReference）</strong></p>
<ol>
<li>
<p>例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);</p>
</li>
<li>
<p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p>
</li>
<li>
<p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p>
</li>
</ol>
<img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901112157901.png" alt="image-20210901112157901" style="zoom:80%;">
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>JavaLearn项目中learJVM.reference.TestPhantomReference - 演示虚引用的基本用法</li>
<li>JavaLearn项目中learJVM.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存</li>
</ul>
</blockquote>
<h2 id="7-finalize">7. finalize</h2>
<p><strong>要求</strong></p>
<ul>
<li>掌握 finalize 的工作原理与缺点</li>
</ul>
<p><strong>finalize</strong></p>
<ul>
<li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li>
<li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li>
</ul>
<p><strong>finalize 原理</strong></p>
<ol>
<li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li>
<li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li>
</ol>
<p><img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901121032813.png" alt="image-20210901121032813"></p>
<ol start="3">
<li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li>
<li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li>
<li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li>
</ol>
<p><img src="file:///d:/MyProject/Learn/LearnNotes/img/image-20210901122228916.png" alt="image-20210901122228916"></p>
<ol start="6">
<li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li>
</ol>
<p><strong>finalize 缺点</strong></p>
<ul>
<li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li>
<li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li>
<li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li>
<li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>JavaLearn项目中learJVM.reference.TestFinalize - finalize 的测试代码</li>
</ul>
</blockquote>

</body>
</html>
